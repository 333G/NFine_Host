using Models;
using Mysoft.Utility;
using Quartz;
using SqlSugar;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using ToolGood.Words;

namespace Mysoft.Task.TaskSet
{
    /// <summary>
    /// 测试任务
    /// </summary>
    ///<remarks>DisallowConcurrentExecution属性标记任务不可并行，要是上一任务没运行完即使到了运行时间也不会运行</remarks>
    [DisallowConcurrentExecution]
    public class SplitPhoneJob : IJob
    {
        private static string connStr = SysConfig.SqlConnect;
        public void Execute(IJobExecutionContext context)
        {
            try
            {
                int listcount = StartJob();
                LogHelper.WriteLog("短信发送测试,当前系统时间:" + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss" + "操作了" + listcount + "条符合条件数据"));
            }
            catch (Exception ex)
            {
                JobExecutionException e2 = new JobExecutionException(ex);
                LogHelper.WriteLog("任务异常", ex);
                //1.立即重新执行任务 
                e2.RefireImmediately = true;
                //2 立即停止所有相关这个任务的触发器
                //e2.UnscheduleAllTriggers=true; 
            }
        }

        //线程方式，返回详单的实体，即拆号码（F_MobileList）
        private List<Sev_SendDateDetail> GetSevSendDateDetailParallel(List<SMC_SendSms> SendList)
        {
            List<Sev_SendDateDetail> list_sev_sdd = new List<Sev_SendDateDetail>();//返回待发送数据的记录   
            Parallel.ForEach(SendList, item =>
            {
                List<Sev_SendDateDetail> list_catch_sdd = new List<Sev_SendDateDetail>();//每个用户的缓存发送列表,用于单个用户发送任务的计费。
                int MoblieCount = 0;
                Dictionary<decimal, int> dic = GetGroupChannel(item.F_GroupChannelId);//获取短信单价以及基准移动通道Id
                decimal ChannelPrice = 0;
                int BaseMobileChannelId = 0;
                foreach (var element in dic)
                {
                    ChannelPrice = element.Key;//获取通道单价
                    BaseMobileChannelId = element.Value;//获取基准处理通道Id
                }
                if (ChenkBalance(item.F_SmsContent, item.F_MobileList, ChannelPrice, item.F_CreatorUserId,BaseMobileChannelId,item.F_Id))//余额判断，如果余额够，扣费,并且更新发送表的总金额
                {
                    if (item.F_MobileList != null)
                    {
                        Sev_SendDateDetail ssdd = new Sev_SendDateDetail();//生成实体对象
                        ssdd.SMC_F_Id = item.F_Id;
                        ssdd.F_RootId = item.F_RootId.ObjToInt();
                        ssdd.F_UserId = GetUserInfo(item.F_CreatorUserId).F_UserId.ObjToInt();
                        ssdd.F_BlackWhite = 1;//默认没有黑白名单
                        ssdd.F_DealState = 0;//默认可以拆分状态
                        ssdd.F_CreatorUserId = item.F_CreatorUserId;
                        ssdd.F_Level = item.F_Priority;//优先级继承
                        ssdd.F_SendTime = item.F_SendTime;//发送时间继承（其实是前台的提交时间，或者定时发送的时间）
                        ssdd.F_Reissue = 0;//补发次数初始为0
                        ssdd.F_Price = ChannelPrice;//获取短信单价
                        ssdd.F_IsCashBack = false;//默认没有返款
                                                  //ssdd.F_Response = 0;//默认应答状态为0
                        ssdd.F_Buckle = 0;//初始没有扣量
                       //取签名和签名位置
                        ssdd.F_SignLocation = GetSignatureLocation(BaseMobileChannelId);//取签名位置，1前；2后；3无
                        ssdd.F_UserSignature = GetUsersignature(item.F_CreatorUserId);//取用户签名
                        string Subscrib = IsSubscrib(BaseMobileChannelId);//根据基准移动通道Id获取是否开启退订，如果返回值不是null，就是开启退订。

                        string[] mobilelist = item.F_MobileList.Split(',');
                        int MobileCount = mobilelist.Count();
                        List<int> RadomList = new List<int>();//随机数列
                        if (MobileCount > 500)//发送号码数量>500才进入扣量程序
                        {
                            OC_GroupChannel ChannelModel = GetSendRate(item.F_GroupChannelId);//对队列进行发送率，成功率与扣量计算处理
                            decimal SendRate = (decimal)ChannelModel.F_SendRate.ObjToInt() / 100;//发送率
                            decimal RemoveNum = Math.Floor(mobilelist.Count() * (1 - SendRate));//获取扣量条数,向下取整数
                            Random radom = new Random();
                            for (int x = 0; x < RemoveNum; x++)//获取不重复的随机数
                            {
                                int RadomNum = radom.Next(0, MobileCount - 1);
                                if (!RadomList.Contains(RadomNum)) //集合list不包含num，就把num添加进list。这样保证随机数不重复
                                {
                                    RadomList.Add(RadomNum);
                                }
                                else
                                    x--;
                            }
                            for (int n = 0; n < MobileCount; n++)//每个号码添加一个详单到list
                            {
                                if (RadomList.Contains(n))
                                {
                                    ssdd.F_Buckle = 1;//被扣量
                                    ssdd.F_DealState = 3;//如果n在随机队列之内，F_DealState直接变为3，扣量状态（前台显示已发送，但是实际上不给发。可以写补发程序进行补发）
                                }

                                ssdd.F_PhoneCode = mobilelist[n].Replace("\t", "");
                                string[] PhoneCodeAndlocatiostring = (GetOperatoeAndLocation(ssdd.F_PhoneCode)).Split(';');//根据号码查运营商和号码归属地
                                ssdd.F_Operator = PhoneCodeAndlocatiostring[0].ObjToInt();//运营商
                                ssdd.F_ChannelId = GetChannelId(ssdd.F_Operator.ObjToInt(), item.F_GroupChannelId);/// 根据运营商，更新成BaseChannelId
                                if (ssdd.F_ChannelId == 0)
                                    ssdd.F_DealState = 2;
                                ssdd.F_ProtocolType = GetProtocol(ssdd.F_ChannelId.ObjToInt());//获取发送协议类型
                                ssdd.F_Province = PhoneCodeAndlocatiostring[1];//省份

                                int LinmitNum = GetUserInfo(item.F_CreatorUserId).F_MessageNum.ObjToInt();
                                if (LinmitNum != 0 && LinmitNum >= DailySendCount(ssdd.F_PhoneCode))
                                    ssdd.F_DealState = 5;//号码超过发送次数限制，拆分但是不发送。
                                int verificationNum_1 = GetUserInfo(item.F_CreatorUserId).F_OneCode.ObjToInt();
                                int verificationNum_24 = GetUserInfo(item.F_CreatorUserId).F_TwentyFourCode.ObjToInt();
                                if (verificationNum_1 != 0 && verificationNum_1 >= OneHourverificationCount(ssdd.F_PhoneCode))
                                    ssdd.F_DealState = 5;//号码超过发送次数限制，拆分但是不发送。
                                if (verificationNum_24 != 0 && verificationNum_24 >= DailyverificationCount(ssdd.F_PhoneCode))
                                    ssdd.F_DealState = 5;//号码超过发送次数限制，拆分但是不发送。

                                //ssdd.F_ChannelSignature//暂时无此适配
                                ssdd.F_SmsContent = item.F_SmsContent;//添加短信

                               //List<Sev_SendDateDetail> SubmitSendDateList = GetSubmitSendDateList(ssdd);//拆大段，获取拆大段的List
                               // ssdd.F_SmsContent = AddLongSmsSign(ssdd.F_ChannelId.ObjToInt(), ssdd.F_UserSignature, ssdd.F_SignLocation, ssdd.F_SmsContent);//，判断退订，并且添加对应标记字符吗，添加签名
                                list_sev_sdd.AddRange(GetSubmitSendDateList(ssdd,Subscrib, BaseMobileChannelId));//拆大段，获取拆大段的List
                            }
                        }
                        else//不进入扣量程序
                        {
                            for (int n = 0; n < MobileCount; n++)//每个号码添加一个详单到list
                            {
                                ssdd.F_PhoneCode = mobilelist[n].Replace("\t", "");

                                string[] PhoneCodeAndlocatiostring = (GetOperatoeAndLocation(ssdd.F_PhoneCode)).Split(';');//根据号码查运营商和号码归属地

                                ssdd.F_Operator = PhoneCodeAndlocatiostring[0].ObjToInt();//运营商
                                ssdd.F_ChannelId = GetChannelId(ssdd.F_Operator.ObjToInt(), item.F_GroupChannelId);/// 根据运营商，更新成BaseChannelId
                                if (ssdd.F_ChannelId == 0)
                                    ssdd.F_DealState = 2;
                                ssdd.F_ProtocolType = GetProtocol(ssdd.F_ChannelId.ObjToInt());//获取发送协议类型
                                ssdd.F_Province = PhoneCodeAndlocatiostring[1];//省份

                                int LinmitNum = GetUserInfo(item.F_CreatorUserId).F_MessageNum.ObjToInt();
                                if (LinmitNum != 0 && LinmitNum >= DailySendCount(ssdd.F_PhoneCode))
                                    ssdd.F_DealState = 5;//号码超过发送次数限制，不发送。
                                int verificationNum_1 = GetUserInfo(item.F_CreatorUserId).F_OneCode.ObjToInt();
                                int verificationNum_24 = GetUserInfo(item.F_CreatorUserId).F_TwentyFourCode.ObjToInt();
                                if (verificationNum_1 != 0 && verificationNum_1 >= OneHourverificationCount(ssdd.F_PhoneCode))
                                    ssdd.F_DealState = 5;//号码超过发送次数限制，不发送。
                                if (verificationNum_24 != 0 && verificationNum_24 >= DailyverificationCount(ssdd.F_PhoneCode))
                                    ssdd.F_DealState = 5;//号码超过发送次数限制，不发送。

                                //ssdd.F_ChannelSignature//暂时无此适配
                                ssdd.F_SmsContent = item.F_SmsContent;//添加短信

                                // List<Sev_SendDateDetail> SubmitSendDateList = GetSubmitSendDateList(ssdd);//拆大段，获取拆大段的List。
                                //  ssdd.F_SmsContent = AddLongSmsSign(ssdd.F_ChannelId.ObjToInt(), ssdd.F_UserSignature, ssdd.F_SignLocation, ssdd.F_SmsContent);//，判断退订，并且添加对应标记字符吗，添加签名
                                list_sev_sdd.AddRange(GetSubmitSendDateList(ssdd,Subscrib,BaseMobileChannelId));//拆大段，获取拆大段的List
                            }
                        }
                    }
                    BlackWhiteCheckedParallel(list_sev_sdd);//线程判断黑名单
                }
                else
                {
                    ChangesendStateDone(item.F_Id);//发送余额不足，整条打回发送表
                }
            });
            return list_sev_sdd;//返回发送详单数据列表
        }


//        ////长短信的标记添加,退订标记添加，签名添加
//        private string AddLongSmsSign(int BaseChannelId, string UserSignature, int SignatureLocation, string smscontent)
//        {
//            int Count = 1;
//            string newsmscontent = null;//新的信息内容
//            string Subscrib = IsSubscrib(BaseChannelId);

//            OC_BaseChannel BaseChannelModel = new OC_BaseChannel();
//            OC_GroupChannel GroupChannelModel = new OC_GroupChannel();

//            using (SqlSugarClient db = new SqlSugarClient(connStr))
//            {
//                BaseChannelModel = db.Queryable<OC_BaseChannel>().SingleOrDefault(t => t.Id == BaseChannelId);//取通道

//            }
//            int MaxLength = BaseChannelModel.F_LongSmsNumber.ObjToInt();//单长短信最大字符数
//            int Length;//短信内容总长度

//            if (UserSignature != null)//有签名
//            {
//                if (Subscrib != null)
//                    Length = smscontent.Length + UserSignature.Length + Subscrib.Length;
//                else
//                    Length = smscontent.Length + UserSignature.Length;
//            }
//            else//没签名
//            {
//                if (Subscrib != null)
//                    Length = smscontent.Length + Subscrib.Length;
//                else
//                    Length = smscontent.Length;
//            }

//            if (Length > MaxLength)
//            {
//                Count += Length / MaxLength;
////==============================================================================================================================================================================
//                if (SignatureLocation == 1)//开启签名且前置
//                {
//                    for (int i = 0; i < Count; i++)
//                    {
//                        newsmscontent += UserSignature;//前置签名
//                        newsmscontent += i + 1 + "/" + Count + ")";
//                        if ((i + 1) * MaxLength > smscontent.Length)
//                            newsmscontent += smscontent.Substring(i * MaxLength, (i + 1) * MaxLength);
//                        else
//                            newsmscontent += smscontent.Substring(i * MaxLength, smscontent.Length);//避免超出长度
//                    }
//                }
//                else if (SignatureLocation == 2)//开启签名且后置
//                {
//                    for (int i = 0; i < Count; i++)
//                    {
//                        newsmscontent += i + 1 + "/" + Count + ")";
//                        if ((i + 1) * MaxLength > smscontent.Length)
//                            newsmscontent += smscontent.Substring(i * MaxLength, (i + 1) * MaxLength);
//                        else
//                            newsmscontent += smscontent.Substring(i * MaxLength, smscontent.Length);
//                        newsmscontent += UserSignature;//后置签名
//                    }
//                }
//                else//不开启签名
//                {
//                    for (int i = 0; i < Count; i++)
//                    {
//                        newsmscontent += i + 1 + "/" + Count + ")";
//                        if ((i + 1) * MaxLength > smscontent.Length)
//                            newsmscontent += smscontent.Substring(i * MaxLength, (i + 1) * MaxLength);
//                        else
//                            newsmscontent += smscontent.Substring(i * MaxLength, smscontent.Length);
//                        //不加签名
//                    }
//                }
////==============================================================================================================================================================================
//                if (Subscrib != null)//判断是否开启退订
//                {
//                    newsmscontent += Subscrib;//退订
//                }
//                return newsmscontent;
//            }
//            else
//            {
//                if (Subscrib != null)//判断是否开启退订
//                {
//                    smscontent += Subscrib;//退订
//                }
//                return smscontent;
//            }
//        }

        //拆大段
        private List<Sev_SendDateDetail> GetSubmitSendDateList(Sev_SendDateDetail SendModel,string Subscrib,int BaseMobileChannelId)//根据基础通道Id获取是否开启退订，如果返回值不是null，就是开启退订。
        {
            List<Sev_SendDateDetail> DealedSendList = new List<Sev_SendDateDetail>();
            string SmsContent = SendModel.F_SmsContent;
            
            OC_BaseChannel BaseChannelModel = new OC_BaseChannel();
            using (SqlSugarClient db = new SqlSugarClient(connStr))
            {
                BaseChannelModel = db.Queryable<OC_BaseChannel>().SingleOrDefault(t => t.Id == BaseMobileChannelId);//取通道
            }
            int ChannelMaxLength = BaseChannelModel.F_LongSmsNumber.ObjToInt();//单长短信最大字符数，根据此来拆大段
            if (ChannelMaxLength < 66)
                ChannelMaxLength = 70;
            if (Subscrib != null)//通道开启退订
            {
                StringSearch keyword = new StringSearch();
                string[] s = { Subscrib };//判断是否有退订字符
                keyword.SetKeywords(s);
                if (!keyword.ContainsAny(SmsContent))//内容中没有退订字符
                {
                    SmsContent += Subscrib;//加上通道规定的退订内容
                }
                SendModel.F_LongsmsCount = GetLongSmsCount(SendModel.F_ChannelId.ObjToInt(), SendModel.F_SmsContent);//短信计数,添加的标记字符也算在内
                if (SendModel.F_LongsmsCount < 0)
                {
                    SendModel.F_DealState = 9;//不支持长短信发送，拆分失败
                }
                if (SendModel.F_SignLocation == 1 || SendModel.F_SignLocation == 2)//开启签名
                {
                    int SplitSmsCount = ChannelMaxLength - SendModel.F_UserSignature.Length - 4 - 2;//每条短信的的正文内容数量,4是：“1/n(”,2是签名的【】
                    if (SendModel.F_UserSignature.Length + SmsContent.Length + 2 > ChannelMaxLength)//判断是否拆大段
                    {
                        decimal Count = Math.Ceiling(Convert.ToDecimal(SendModel.F_SmsContent.Length) / SplitSmsCount);//向上取整数
                        for (int i = 0; i < Count; i++)
                        {
                            string newsmscontent = null;
                            Sev_SendDateDetail newSendMode = new Sev_SendDateDetail();//生成实体对象
                            newSendMode = SendModel;//继承内容
                            newSendMode.F_Id = Guid.NewGuid().ToString();
                            if (SendModel.F_SignLocation == 1)//签名在前
                            {
                                if (((i + 1) * SplitSmsCount) < SmsContent.Length)//避免超出长度
                                {
                                    newsmscontent = "【" + SendModel.F_UserSignature + "】" + (i + 1) + "/" + Count + ")" + SmsContent.Substring(i * SplitSmsCount, SplitSmsCount);
                                }
                                else
                                {
                                    newsmscontent = "【" + SendModel.F_UserSignature + "】" + (i + 1) + "/" + Count + ")" + SmsContent.Substring(i * SplitSmsCount, SmsContent.Length - i * SplitSmsCount);
                                }
                            }
                            else//签名在后
                            {
                                if (((i + 1) * SplitSmsCount) < SmsContent.Length)//避免超出长度
                                {
                                    newsmscontent = (i + 1) + "/" + Count + ")"+ SmsContent.Substring(i * SplitSmsCount,  SplitSmsCount) + "【" + SendModel.F_UserSignature + "】";
                                }
                                else
                                {
                                    newsmscontent = (i + 1) + "/" + Count + ")"+ SmsContent.Substring(i * SplitSmsCount, SmsContent.Length - i * SplitSmsCount) + "【" + SendModel.F_UserSignature + "】";
                                }
                            }
                            newSendMode.F_SmsContent = newsmscontent;//新拆分的大段信息内容
                            newSendMode.F_LongsmsCount = Count.ObjToInt();
                            DealedSendList.Add(newSendMode);
                        }
                    }
                    else//不需要拆大段
                    {
                        string newsmscontent = null;
                        if (SendModel.F_SignLocation == 1)//签名在前
                            newsmscontent = "【" + SendModel.F_UserSignature + "】" + SmsContent;
                        else//签名在后
                            newsmscontent = SmsContent + "【" + SendModel.F_UserSignature + "】";

                        Sev_SendDateDetail newSendMode = new Sev_SendDateDetail();
                        newSendMode = SendModel;//继承内容
                        newSendMode.F_Id = Guid.NewGuid().ToString();
                        newSendMode.F_SmsContent = SmsContent;
                        DealedSendList.Add(newSendMode);
                    }
                }
                else//不开启签名
                {
                    int SplitSmsCount = ChannelMaxLength - 4;//每条短信的的正文内容数量,4是：“1/n(”
                    if (SmsContent.Length > ChannelMaxLength)//拆大段
                    {
                        decimal Count = Math.Ceiling(Convert.ToDecimal(SendModel.F_SmsContent.Length) / SplitSmsCount);//向上取整数
                        for (int i = 0; i < Count; i++)
                        {
                            Sev_SendDateDetail newSendMode = new Sev_SendDateDetail();
                            newSendMode = SendModel;
                            newSendMode.F_Id = Guid.NewGuid().ToString();
                            string newsmscontent = null;
                            if ((i + 1) * SplitSmsCount < SmsContent.Length)
                                newsmscontent = (i + 1) + "/" + Count + ")" + SmsContent.Substring(i * SplitSmsCount, SplitSmsCount);
                            else
                                newsmscontent = (i + 1) + "/" + Count + ")" + SmsContent.Substring(i * SplitSmsCount, SmsContent.Length - i * SplitSmsCount);

                            newSendMode.F_SmsContent = newsmscontent;
                            newSendMode.F_LongsmsCount = Count.ObjToInt();
                            DealedSendList.Add(newSendMode);
                        }
                    }
                    else//不拆大段
                    {
                        Sev_SendDateDetail newSendMode = new Sev_SendDateDetail();
                        newSendMode = SendModel;
                        newSendMode.F_Id = Guid.NewGuid().ToString();
                        newSendMode.F_SmsContent = SmsContent;
                        DealedSendList.Add(newSendMode);
                    }
                }
            }
            
            else//通道不开启退订
            {
                SendModel.F_LongsmsCount = GetLongSmsCount(SendModel.F_ChannelId.ObjToInt(), SendModel.F_SmsContent);//短信计数,添加的标记字符也算在内
                if (SendModel.F_LongsmsCount < 0)
                {
                    SendModel.F_DealState = 9;//不支持长短信发送，拆分失败
                }
                if (SendModel.F_SignLocation == 1 || SendModel.F_SignLocation == 2)//开启签名
                {
                    int SplitSmsCount = ChannelMaxLength - SendModel.F_UserSignature.Length - 4 - 2;//每条短信的的正文内容数量,4是：“1/n(”,2是签名的【】
                    if (SendModel.F_UserSignature.Length + SmsContent.Length + 2 > ChannelMaxLength)//判断是否拆大段
                    {
                        decimal Count = Math.Ceiling(Convert.ToDecimal(SendModel.F_SmsContent.Length) / SplitSmsCount);//向上取整数
                        for (int i = 0; i < Count; i++)
                        {
                            string newsmscontent = null;
                            Sev_SendDateDetail newSendMode = new Sev_SendDateDetail();//生成实体对象

                            newSendMode = SendModel;//继承内容
                            newSendMode.F_Id = Guid.NewGuid().ToString();
                            if (SendModel.F_SignLocation == 1)//签名在前
                            {
                                if (((i + 1) * SplitSmsCount) < SmsContent.Length)//避免超出长度
                                {
                                    newsmscontent = "【" + SendModel.F_UserSignature + "】" + (i + 1) + "/" + Count + ")" + SmsContent.Substring(i * SplitSmsCount,  SplitSmsCount);
                                }
                                else
                                {
                                    newsmscontent = "【" + SendModel.F_UserSignature + "】" + (i + 1) + "/" + Count + ")" + SmsContent.Substring(i * SplitSmsCount, SmsContent.Length - i * SplitSmsCount);
                                }
                            }
                            else//签名在后
                            {
                                if (((i + 1) * SplitSmsCount) < SmsContent.Length)//避免超出长度
                                {
                                    newsmscontent = (i + 1) + "/" + Count + ")" + SmsContent.Substring(i * SplitSmsCount, SplitSmsCount) + "【" + SendModel.F_UserSignature + "】";
                                }
                                else
                                {
                                    newsmscontent = (i + 1) + "/" + Count + ")" + SmsContent.Substring(i * SplitSmsCount, SmsContent.Length - i * SplitSmsCount) + "【" + SendModel.F_UserSignature + "】";
                                }
                            }
                            newSendMode.F_SmsContent = newsmscontent;//新拆分的大段信息内容
                            newSendMode.F_LongsmsCount = Count.ObjToInt();
                            DealedSendList.Add(newSendMode);
                        }
                    }
                    else//不需要拆大段
                    {
                        string newsmscontent = null;
                        if (SendModel.F_SignLocation == 1)//签名在前
                            newsmscontent = "【" + SendModel.F_UserSignature + "】" + SmsContent;
                        else//签名在后
                            newsmscontent = SmsContent + "【" + SendModel.F_UserSignature + "】";

                        Sev_SendDateDetail newSendMode = new Sev_SendDateDetail();
                        newSendMode = SendModel;//继承内容
                        newSendMode.F_Id = Guid.NewGuid().ToString();
                        newSendMode.F_SmsContent = SmsContent;
                        DealedSendList.Add(newSendMode);
                    }
                }
                else//不开启签名
                {
                    int SplitSmsCount = ChannelMaxLength - 4;//每条短信的的正文内容数量,4是：“1/n(”
                    if (SmsContent.Length > ChannelMaxLength)//拆大段
                    {
                        decimal Count = Math.Ceiling(Convert.ToDecimal(SendModel.F_SmsContent.Length) / SplitSmsCount);//向上取整数
                        for (int i = 0; i < Count; i++)
                        {
                            Sev_SendDateDetail newSendMode = new Sev_SendDateDetail();
                            newSendMode = SendModel;
                            newSendMode.F_Id = Guid.NewGuid().ToString();
                            string newsmscontent = null;
                            if ((i + 1) * SplitSmsCount < SmsContent.Length)
                                newsmscontent = (i + 1) + "/" + Count + ")" + SmsContent.Substring(i * SplitSmsCount, SplitSmsCount);
                            else
                                newsmscontent = (i + 1) + "/" + Count + ")" + SmsContent.Substring(i * SplitSmsCount, SmsContent.Length - i * SplitSmsCount);

                            newSendMode.F_SmsContent = newsmscontent;
                            newSendMode.F_LongsmsCount = Count.ObjToInt();
                            DealedSendList.Add(newSendMode);
                        }
                    }
                    else//不拆大段
                    {
                        Sev_SendDateDetail newSendMode = new Sev_SendDateDetail();
                        newSendMode = SendModel;
                        newSendMode.F_Id = Guid.NewGuid().ToString();
                        newSendMode.F_SmsContent = SmsContent;
                        DealedSendList.Add(newSendMode);
                    }
                }
            }
            return DealedSendList;
        }


        //线程方式进行黑名单判断，返回SendData的List<>.，为发送做最后的准备。
        private void BlackWhiteCheckedParallel(List<Sev_SendDateDetail> senddatalist)
        {
            List<Models.OC_BlackList> blacklist = GetBlackList();
            Parallel.ForEach(senddatalist, item =>
            {
                foreach (var num in blacklist)
                {
                    if (item.F_PhoneCode == num.F_Mobile)//如果联系电话在黑名单中，修改状态
                    {
                        if (num.F_Sign.ObjToBool())
                        {
                            item.F_BlackWhite = 2;//修改为黑名单
                            item.F_DealState = 7;//报告状态为，黑名单
                            break;
                        }
                        else
                        {
                            item.F_BlackWhite = 3;//系统白名单
                            item.F_Level = 180;//修改优先级
                        }
                    }
                }
            });
        }

        //获取非黑名单号码数量
        private int GetMobileCount(List<Sev_SendDateDetail> list)
        {
            int MobileCount = 0;
            foreach (var item in list)
            {
                if (item.F_DealState == 0||item.F_DealState == 3)//可拆分还有扣量，算作扣费短信数目
                    MobileCount++;
            }
            return MobileCount;
        }

        //修改处理状态
        private List<SMC_SendSms> ChangeOperateStateStar(List<SMC_SendSms> list)
        {
            Parallel.ForEach(list, item =>
            {
                item.F_OperateState = 1; //修改处理状态为处理ing
            });
            using (SqlSugarClient db = new SqlSugarClient(connStr))
            {
                db.UpdateRange(list); //批量更新 发送列表内容的处理状态为处理中
            }
            return list;
        }

        //修改发送状态
        private void ChangeSendState(List<SMC_SendSms> list)
        {
            Parallel.ForEach(list, item =>
             {
                 item.F_OperateState = 9; //修改处理状态为已处理
                 item.F_SendState = 9;//修改发送状态为已发送（测试用）
             });
        }

        //短信内容敏感词处理,线程方法||顺带判断是否为验证码短信
        private List<SMC_SendSms> DirtyWordRemove(List<SMC_SendSms> contentlist)
        {
            string SensitiveStr = GetSensitiveWords();
            if(SensitiveStr!=null)
            {
                Parallel.ForEach(contentlist, item =>
                { 
                    string content = item.F_SmsContent;
                    StringSearch keyword = new StringSearch();
                    keyword.SetKeywords(SensitiveStr.Split('|'));
                    item.F_SmsContent = keyword.Replace(content, '*');
                    string []s = { "验证码" };//判断是否有关键字“验证码”
                    keyword.SetKeywords(s);
                    if (keyword.ContainsAny(content))
                    {
                        item.F_IsVerificationCode = true;//修改，短信验证码标记为true
                    }
                });
            }
            return contentlist;
        }

         //发送短信主程序
         int StartJob()
        {
            var stopWatch = new Stopwatch();
            stopWatch.Start();
            List<SMC_SendSms> ReadyList = GetSMCSendSmsList();//获取列表
            ReadyList= ChangeOperateStateStar(ReadyList);//改为处理中

            ReadyList= DirtyWordRemove(ReadyList);//敏感词替换，判断是否为验证码,处理list
            
            List<Sev_SendDateDetail> SendDataList = GetSevSendDateDetailParallel(ReadyList);//线程方式获取发送数据（黑名单检测通过）
            int count = SendDataList.Count();//计数

            //修改状态为已处理，
            ChangeSendState(ReadyList);
            //
            try
            {
                using (SqlSugarClient db = new SqlSugarClient(connStr))//开启数据库连接
                { 
                    db.SqlBulkCopy(SendDataList); //批量插入 海量数据插入Sev_SendDateDetail，插入之后就清楚list//SEV_SendDataDetail数据插入（有黑名单验证）
                    //db.InsertRange(SendDataList);//批量插入数据（备用方法）,不会删除list

                    db.SqlBulkReplace(ReadyList); //批量更新 海量数据更新SMC_SendSms（是否为验证码，以及短信内容替换敏感词
                }
            }
            catch (Exception ex){
                Console.WriteLine(ex);
                Console.Read();
            }
            stopWatch.Stop();
            Console.WriteLine("线程============"+ stopWatch.ElapsedMilliseconds);
            return count;
        }

//****************************************************************************修改，获取数据**************************************************************************************
       
        //取得发送表数据，已审核，待发送，处理中，F_DealState=9，F_SendState=0，F_OperateState=0，//已审核，未处理，未发送//根据优先级排序(大的在前）
        private List<SMC_SendSms> GetSMCSendSmsList()
        {
            List<SMC_SendSms> list_smc_sendsms = new List<SMC_SendSms>();
            using (SqlSugarClient db = new SqlSugarClient(connStr))//开启数据库连接
            {
                list_smc_sendsms = db.SqlQuery<SMC_SendSms>("select F_Id,F_MobileList,F_CreatorUserId,F_MobileCount,F_SmsContent,F_RootId,F_GroupChannelId,F_DealState,F_SendState,F_Priority,F_SendSign from SMC_SendSms where F_DealState=9 and F_SendState=0 and F_OperateState=0 ORDER BY F_Priority DESC");
            }
            return list_smc_sendsms;
        }

        //根据组合通道F_ID取得GroupChannel实体对象
        private OC_GroupChannel GetSendRate(string GroupChannelF_Id)
        {
            OC_GroupChannel groupchannel = new OC_GroupChannel();
            using (SqlSugarClient db = new SqlSugarClient(connStr))
            {
                string sql = "select F_SendRate,F_SuccessRate from OC_GroupChannel where F_ID = @GroupChannelF_Id";//获取F_Reviewed
                groupchannel = db.SqlQuery<OC_GroupChannel>(sql, new { GroupChannelF_Id = GroupChannelF_Id }).Single();
            }
            return groupchannel;
        }

        ////修改处理状态为已处理
        //private void ChangeOperateState(string F_Id)
        //{
        //    using (SqlSugarClient db = new SqlSugarClient(connStr))
        //    {
        //        db.Update<SMC_SendSms>(new { F_OperateState = 9 }, it => it.F_Id == F_Id);
        //    }
        //}

        //取得黑名单列表
        private List<Models.OC_BlackList> GetBlackList()
        {
            List<Models.OC_BlackList> list_blacklist = new List<Models.OC_BlackList>();
            using (SqlSugarClient db = new SqlSugarClient(connStr))//开启数据库连接
            {
                string sql = "select Mobile from TXL_BlackList";
                list_blacklist = db.SqlQuery<Models.OC_BlackList>(sql);
            }
            return list_blacklist;
        }

        //获取发送数据（号码）//已经进行黑名单校验
        private List<Sev_SendDateDetail> GetSendData(string SMC_FId)
        {
            List<Sev_SendDateDetail> SendDatalist = new List<Sev_SendDateDetail>();
            using (SqlSugarClient db = new SqlSugarClient(connStr))//开启数据库连接
            {
                string sql = "select F_Id,F_PhoneCode,F_UserId from Sev_SendDateDetail where SMC_F_Id = @SMC_FId";
                SendDatalist = db.SqlQuery<Sev_SendDateDetail>(sql,new { SMC_FId = SMC_FId });
            }
            return SendDatalist;
        }

        //获取系统敏感词字符串
        private string GetSensitiveWords()
        {
            List<SMS_SensitiveWords> Sensitivelist = new List<SMS_SensitiveWords>();
            try
            {
                using (SqlSugarClient db = new SqlSugarClient(connStr))
                {
                    string sql = "select F_SensitiveWords from SMS_SensitiveWords";
                    Sensitivelist = db.SqlQuery<SMS_SensitiveWords>(sql);
                }
                string SensitiveStr = null;
                foreach (var item in Sensitivelist)
                {
                    SensitiveStr += item.F_SensitiveWords + "|";
                }
                return SensitiveStr;
            }
            catch
            {
                return null;
            }
        }

        //根据用户F_Id获取Id和24小时验证码发送量，1小时验证码发送量，每个号码接收短信次数限制量
        private Models.OC_UserInfo GetUserInfo(string F_Id)
        {
            using (SqlSugarClient db = new SqlSugarClient(connStr))
            {
                string sql = "select F_UserId from OC_UserInfo where F_Id=@F_Id";
                Models.OC_UserInfo data=db.SqlQuery<Models.OC_UserInfo>(sql,new { F_Id=F_Id}).Single();
                return data;
            }
        }

        //根据号码获取当天的发送量
        private int DailySendCount (string PhoneCode)
        {
            int count = 0;
            using (SqlSugarClient db = new SqlSugarClient(connStr))
            {
                //获取某个号码，当天之内的发送次数
                count = db.Queryable<Sev_SendDateDetail>().Where(t => t.F_PhoneCode == PhoneCode && DateTime.Today < t.F_SendTime && t.F_SendTime < DateTime.Today.AddDays(+1)).Count();
            }
            return count;
        }

        //根据号码获取当日的验证码发送限制
        private int DailyverificationCount(string PhoneCode)
        {
            int count = 0;
            using (SqlSugarClient db = new SqlSugarClient(connStr))
            {
                //获取某个号码当天发送的验证码次数
                count = db.Queryable<Sev_SendDateDetail>().Where(t => t.F_PhoneCode == PhoneCode && DateTime.Today < t.F_SendTime && t.F_SendTime < DateTime.Now).Count();
            }
            return count;
        }

        //根据号码获取一小时的验证码发送限制
        private int OneHourverificationCount(string PhoneCode)
        {
            int count = 0;
            using (SqlSugarClient db = new SqlSugarClient(connStr))
            {
                //获取某个号码当天发送的验证码次数
                count = db.Queryable<Sev_SendDateDetail>().Where(t => t.F_PhoneCode == PhoneCode && DateTime.Now.AddHours(-1) < t.F_SendTime && t.F_SendTime < DateTime.Now.AddHours(+1)).Count();
            }
            return count;
        }
        //根据号码获取运营商和归属地
        private string GetOperatoeAndLocation(string PhoneCode)
        {
            PhoneCode = PhoneCode.Substring(0, 7);//取号码的前7位进行判断
            Sys_PhoneNumAreaInfo PhoneInfo = new Sys_PhoneNumAreaInfo();
            string codeandlocation=null;
            try
            {
                using (SqlSugarClient db = new SqlSugarClient(connStr))
                {
                    //PhoneInfo = db.Queryable<Sys_PhoneNumAreaInfo>().SingleOrDefault(t => t.F_NumSegment == PhoneCode);
                    string sql = "select F_Operator,F_PostCode from Sys_PhoneNumAreaInfo where F_NumSegment = @PhoneCode";
                    PhoneInfo = db.SqlQuery<Sys_PhoneNumAreaInfo>(sql, new { PhoneCode = PhoneCode }).Single();
                }
                if (PhoneInfo.F_Operator == "中国移动" || PhoneInfo.F_Operator == "移动")
                    codeandlocation = "1" + ";";
                else if (PhoneInfo.F_Operator == "中国联通" || PhoneInfo.F_Operator == "联通")
                    codeandlocation = "2" + ";";
                else
                    codeandlocation = "3" + ";";

                codeandlocation += PhoneInfo.F_PostCode;
                return codeandlocation;
            }
            catch { return "0" + ";" + "未知"; }
          
        }

        //根据运营商获取组合通道内的基础通道
        private int GetChannelId(int Operator, string GroupChannelId)
        {
            int ChannelId=0;
            try
            {
                using (SqlSugarClient db = new SqlSugarClient(connStr))
                {
                    if (Operator == 1)//移动
                        ChannelId = db.Queryable<OC_GroupChannel>().SingleOrDefault(t => t.F_ID == GroupChannelId).F_MobileChannel.ObjToInt();
                    else if (Operator == 2)//联通
                        ChannelId = db.Queryable<OC_GroupChannel>().SingleOrDefault(t => t.F_ID == GroupChannelId).F_UnicomChannel.ObjToInt();
                    else
                        ChannelId = db.Queryable<OC_GroupChannel>().SingleOrDefault(t => t.F_ID == GroupChannelId).F_TelecomChannel.ObjToInt();
                }
            }
            catch
            { return 0; }
            return ChannelId;
        }

        //根据通道Id获取对应的发送协议
        private int GetProtocol(int ChannelId)
        {
            int ProtocolType ;
            try
            {
                using (SqlSugarClient db = new SqlSugarClient(connStr))
                {
                    ProtocolType = db.Queryable<OC_ChannelConfig>().Single(t => t.F_ChannelId == ChannelId).F_ProtocolType;
                }
                return ProtocolType;
            }
            catch
            { return 1; }
        }

        //根据通道Id获取长短信计数
        private int GetLongSmsCount(int ChannelId, string smscontent)
        {
            int CharacterCount = 0;
            OC_BaseChannel BaseChannelModel = new OC_BaseChannel();
            using (SqlSugarClient db = new SqlSugarClient(connStr))
            {
                BaseChannelModel = db.Queryable<OC_BaseChannel>().SingleOrDefault(t => t.Id == ChannelId);
            }
            CharacterCount = BaseChannelModel.F_CharacterCount.ObjToInt();
            int ContentCount = 1;
            if (CharacterCount * ContentCount < smscontent.Length)
            {
                ContentCount++;
            }
            if (BaseChannelModel.F_LongSmsSign == false)
            {
                if(ContentCount > 1)
                    return -1;//不支持长短信却发了长短信
            }
            return ContentCount;
        }

        //判断是否退订
        private string IsSubscrib(int BaseChannelId)
        {
            string F_IsSubscrib;
            using (SqlSugarClient db = new SqlSugarClient(connStr))
            {
                F_IsSubscrib = db.Queryable<OC_BaseChannel>().SingleOrDefault(t => t.Id == BaseChannelId).F_unsubscribe;
            }
            if (F_IsSubscrib == null || F_IsSubscrib == "")
                return null;//不开启退订
            else return F_IsSubscrib;//开启退订，返回退订内容
        }

        //根据通道Id取出单价
        private Dictionary<decimal, int> GetGroupChannel(string GroupChannelId)
        {
            Dictionary<decimal, int> dic = new Dictionary<decimal, int>();
            using (SqlSugarClient db = new SqlSugarClient(connStr))
            {
                OC_GroupChannel GroupChannelModel = db.Queryable<OC_GroupChannel>().SingleOrDefault(t => t.F_ID == GroupChannelId);
                int BaseMobileChannelId = GroupChannelModel.F_MobileChannel.ObjToInt();
                decimal  ChannelPrice = GroupChannelModel.F_ChannelPrice.ObjToDecimal();
                dic.Add(ChannelPrice,BaseMobileChannelId);
            }
            return dic;
        }

        //判断余额
        private bool ChenkBalance(string SmsContent,string MobileList,decimal ChannelPrice,string UserF_Id,int BaseMobileChannelId,string SendFId)
        {
            decimal Balance = 0;
            decimal cost = 0;
            decimal SMS_number = 0;
            int SmsCount = 0;//计费短信条数
            string Subscrib = IsSubscrib(BaseMobileChannelId);//根据基准移动通道Id获取是否开启退订，如果返回值不是null，就是开启退订。
            string UserSignature = GetUsersignature(UserF_Id);
            string[] mobilelist = MobileList.Split(',');
            int MobileCount = mobilelist.Count();//号码数
            OC_BaseChannel BaseChannelModel = new OC_BaseChannel();
            using (SqlSugarClient db = new SqlSugarClient(connStr))
            {
                BaseChannelModel = db.Queryable<OC_BaseChannel>().SingleOrDefault(t => t.Id == BaseMobileChannelId);//取基准通道Model
            }
            int ChannelMaxLength = BaseChannelModel.F_LongSmsNumber.ObjToInt();//单长短信最大字符数，根据此来拆大段
            int F_SignLocation = BaseChannelModel.F_autograph;//签名位置，1前；2后；3无
            if (Subscrib != null)//通道开启退订
            {
                StringSearch keyword = new StringSearch();
                string[] s = { Subscrib };//判断是否有退订字符
                keyword.SetKeywords(s);
                if (!keyword.ContainsAny(SmsContent))//内容中没有退订字符
                {
                    SmsContent += Subscrib;//加上通道规定的退订内容
                }

                if (F_SignLocation == 1 || F_SignLocation == 2)//开启签名
                {
                    if ((SmsContent.Length + UserSignature.Length + 2) > ChannelMaxLength)//需要拆大段
                    {
                        int SplitSmsCount = ChannelMaxLength - UserSignature.Length - 4 - 2;//每条大段的的正文内容数量,4是：“1/n(”,2是签名加上的【】
                        SmsCount = Math.Ceiling(Convert.ToDecimal(SmsContent.Length) / SplitSmsCount).ObjToInt();//预估拆成的大段de数目
                        decimal LetterCount = SmsContent.Length + (UserSignature.Length + 2 + 4) * SmsCount;//总字数：【内容字数+预估大段数*（签名+2+4）】,4是：“1/n(”,2是签名加上的【】
                        SMS_number = Math.Ceiling(LetterCount / 66);//单条计费信息条数：总字数/66=实际发送条数(向上取整)
                        cost = SMS_number * ChannelPrice * MobileCount;//该批信息总费用：实际发送条数*号码个数*组合通道单价
                    }
                    else//不拆大段
                    {
                        decimal LetterCount = SmsContent.Length + UserSignature.Length + 2;//总字数。内容字数+签名+2 ,2是签名加上的【】
                        SMS_number = Math.Ceiling(LetterCount / 66);//单条计费信息条数：总字数/66=实际发送条数(向上取整)
                        cost = SMS_number * ChannelPrice * MobileCount;
                    }

                }
                else//没有签名
                {
                    if (SmsContent.Length>ChannelMaxLength)//拆大段
                    {
                        int SplitSmsCount = ChannelMaxLength - 4 ;//每条大段的的正文内容数量,4是：“1/n(”
                        SmsCount = Math.Ceiling(Convert.ToDecimal(SmsContent.Length) / SplitSmsCount).ObjToInt();//预估拆成的大段de数目
                        decimal LetterCount = SmsContent.Length + 4 * SmsCount;//总字数：【内容字数+预估大段数*（4）】,4是：“1/n(”
                        SMS_number = Math.Ceiling(LetterCount / 66);//单条信息计费条数：总字数/66=实际发送条数(向上取整)
                        cost = SMS_number * ChannelPrice * MobileCount;
                    }
                    else//不拆大段
                    {
                        SMS_number = Math.Ceiling(Convert.ToDecimal(SmsContent.Length) / 66);//单条计费信息条数：总字数/66=实际发送条数(向上取整)
                        cost = SMS_number * ChannelPrice * MobileCount;
                    }
                }
            }
            else//不退订
            {
                if (F_SignLocation == 1 || F_SignLocation == 2)//开启签名
                {
                    if ((SmsContent.Length + UserSignature.Length + 2) > ChannelMaxLength)//需要拆大段
                    {
                        int SplitSmsCount = ChannelMaxLength - UserSignature.Length - 4 - 2;//每条大段的的正文内容数量,4是：“1/n(”,2是签名加上的【】
                        SmsCount = Math.Ceiling(Convert.ToDecimal(SmsContent.Length) / SplitSmsCount).ObjToInt();//预估拆成的大段de数目
                        decimal LetterCount = SmsContent.Length + (UserSignature.Length + 2 + 4) * SmsCount;//总字数：【内容字数+预估大段数*（签名+2+4）】,4是：“1/n(”,2是签名加上的【】
                        SMS_number = Math.Ceiling(LetterCount / 66);//单条计费信息条数：总字数/66=实际发送条数(向上取整)
                        cost = SMS_number * ChannelPrice * MobileCount;//该批信息总费用：实际发送条数*号码个数*组合通道单价
                    }
                    else//不拆大段
                    {
                        decimal LetterCount = SmsContent.Length + UserSignature.Length + 2;//总字数。内容字数+签名+2 ,2是签名加上的【】
                        SMS_number = Math.Ceiling(LetterCount / 66);//单条计费信息条数：总字数/66=实际发送条数(向上取整)
                        cost = SMS_number * ChannelPrice * MobileCount;
                    }

                }
                else//没有签名
                {
                    if (SmsContent.Length > ChannelMaxLength)//拆大段
                    {
                        int SplitSmsCount = ChannelMaxLength - 4;//每条大段的的正文内容数量,4是：“1/n(”
                        SmsCount = Math.Ceiling(Convert.ToDecimal(SmsContent.Length) / SplitSmsCount).ObjToInt();//预估拆成的大段de数目
                        decimal LetterCount = SmsContent.Length + 4 * SmsCount;//总字数：【内容字数+预估大段数*（4）】,4是：“1/n(”
                        SMS_number = Math.Ceiling(LetterCount / 66);//单条信息计费条数：总字数/66=实际发送条数(向上取整)
                        cost = SMS_number * ChannelPrice * MobileCount;
                    }
                    else//不拆大段
                    {
                        SMS_number = Math.Ceiling(Convert.ToDecimal(SmsContent.Length) / 66);//单条计费信息条数：总字数/66=实际发送条数(向上取整)
                        cost = SMS_number * ChannelPrice * MobileCount;
                    }
                }
            }

            using (SqlSugarClient db = new SqlSugarClient(connStr))
            {
                Models.OC_UserInfo usermodel = db.Queryable<Models.OC_UserInfo>().Single(t => t.F_UserFid == UserF_Id);
                if (usermodel.F_Balance > cost)//余额充足
                {
                    Balance = usermodel.F_Balance - cost;
                    db.Update<Models.OC_UserInfo>(new { F_Balance = Balance }, it => it.F_UserFid == UserF_Id);//更新用户余额（扣费）
                    db.Update<SMC_SendSms>(new { F_Price = cost }, it => it.F_Id == SendFId);//更新发送表的金额数
                    return true;
                }
                else//余额不足,不扣费，直接打回总条发送任务
                    return false;
            }
        }

        //获取用户签名
        private string GetUsersignature(string F_Id)
        {
            string UserSignature;
            using (SqlSugarClient db = new SqlSugarClient(connStr))
            {
                string sql = "select F_Signature from Sys_User where F_Id=@F_Id";
                UserSignature = db.SqlQuery<Sys_User>(sql, new { F_Id = F_Id }).Single().F_Signature;
            }
                return UserSignature;
        }

        //签名位置
        private int GetSignatureLocation(int BaseMobileChannelId)
        {
            int F_SignLocation = 3;
            using (SqlSugarClient db = new SqlSugarClient(connStr))
            {
                F_SignLocation = db.Queryable<OC_BaseChannel>().SingleOrDefault(t => t.Id == BaseMobileChannelId).F_autograph;//签名位置，1前；2后；3无
            }

            return F_SignLocation;
        }

        //修改处理状态为余额不足
        private void ChangesendStateDone(string F_Id)
        {
            using (SqlSugarClient db = new SqlSugarClient(connStr))
            {
                db.Update<SMC_SendSms>(new { F_OperateState = -1 }, it => it.F_Id == F_Id);
            }
        }

        //class newSenModel//封装一个实体类,防止干扰
        //{
     
        //    Sev_SendDateDetail senddatedetail = new Sev_SendDateDetail();
        //    public Sev_SendDateDetail newsenddatedetaiModel
        //    {
        //        get
        //        {
        //            return senddatedetail;
        //        }
        //    }
        //}


    }
}
